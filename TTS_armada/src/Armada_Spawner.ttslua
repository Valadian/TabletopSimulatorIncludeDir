#include ui/ui

DEF_BRACE = '79d121'
DEF_CONTAIN = '68abfc'
DEF_EVADE = 'c09d88'
DEF_REDIRECT = '36f595'
DEF_SCATTER = '895e91'
DEF_SALVO = '5028b2'

SPEED_SOURCE = 'b75a56'
COMMAND_SOURCE = '2516df'
function update()
    for _,card in ipairs(getAllObjects()) do
        if card.tag == 'Card' and card.getName()~=nil then
            local cmd = card.getDescription()
            local oldName = card.getVar('oldName')
            card.setVar('oldName',card.getName())
            if cmd:starts "spawn" then
                if oldName ~= card.getName() then
                    card.setName(oldName)
                end
                local count = tonumber(cmd:match "spawn%s(.*)")
                if count == nil then count = 1 end
                printToAll("Spawn ship '"..card.getName().."'",{0,1,1})
                spawnShip(card.getName(),card.getPosition(),count,card.getRotation()[2])
                card.setDescription("")
                card.clearButtons()
                --card.lock()
            end
        end
    end
end
Ship = {
    collider = "",
    convex = true,
    type = 1,
    material = 3,
    maneuver = {},
    defense_tokens = {},
    shields = {1,1,1,1,1,1},
    cost = 0,
    name = "",
    front = "",
    back = "",
    aliases = {}
}
function Ship:new (o,...)
    o = o or {}
    o = table.copy(o)
    if ... ~= nil then
        for i,tab in ipairs({...}) do
            for k, v in pairs(tab) do
                o[k] = v
            end
        end
    end
    setmetatable(o, Ship)
    Ship.__index = Ship
    Cache(SHIPS,o)
    return o
end
SmallShip = {
    collider = "http://paste.ee/r/eDbf1"
}
MediumShip = {
    collider = "http://paste.ee/r/6LYTT"
}
LargeShip = {
    collider = "http://paste.ee/r/a7mfW"
}
HugeShip = {
    collider = "http://paste.ee/r/ClCL3"
}
Squadron = {
    collider = "http://paste.ee/r/nAMCQ",
    convex = false,
    type = 1,
    material = 1,
    defense_tokens = {},
    cost = 0,
    name = "",
    front = "",
    back = "",
    aliases = {}
}
function Squadron:new (o, ...)
    o = o or {}
    o = table.copy(o)
    if ... ~= nil then
        -- printToAll("Found args: "..tostring(#{...}),{0,1,1})
        for i,tab in ipairs({...}) do
            for k, v in pairs(tab) do
                -- printToAll("Copying over: "..k)
                o[k] = v
            end
        end
    end
    setmetatable(o, Squadron)
    Squadron.__index = Squadron
    -- if o.name == nil then
    --     for k, v in pairs(o) do
    --         printToAll(k..":"..tostring(v),{1,0,0})
    --     end
    -- end
    -- if o.cost == nil then
    --     printToAll(o.name.." has no cost",{1,0,0})
    -- end
    Cache(SHIPS,o)
    -- if key~=key_noclass then
    --     printToAll(key.." ~= "..key_noclass,{1,1,0})
    -- end
    return o
end
function Cache(DEFS,o)
    -- FUZZY[string.lower(o.name)] = o
    DEFS[string.lower(o.name.." ("..o.cost..")")] = o
    CacheNgrams(o.name.." ("..o.cost..")")
    DEFS[string.lower(o.name)] = o
    -- CacheNgrams(o.name)
    for _,alias in ipairs(o.aliases) do
        DEFS[string.lower(alias.." ("..o.cost..")")] = o
        CacheNgrams(alias.." ("..o.cost..")")
        DEFS[string.lower(alias)] = o
        -- CacheNgrams(alias)
    end
end
NGRAMS = {}
function CacheNgrams(name)
    name = string.lower(name)
    n = #name
    s = " "..name.." "
    -- if name=="acclamator ii" then
    --     print("Caching Ngrams for "..name)
    -- end
    for i = 1,n do
        sub = string.sub(s,i,i+2)
        -- if name=="acclamator ii" then
        --     print("Adding: '"..name.."' for: '"..sub.."'")
        -- end
        if NGRAMS[sub]==nil then
            NGRAMS[sub]={name}
        else
            table.insert(NGRAMS[sub],name)
        end
    end
end
Card = {
    cost = 0,
    name = "",
    type = "",
    front = "",
    back = "",
    aliases = {},
    iscard = true -- to replace checking for "type"
}
function Card:new (o, ...)
    o = o or {}
    o = table.copy(o)
    if ... ~= nil then
        -- printToAll("Found args: "..tostring(#{...}),{0,1,1})
        for i,tab in ipairs({...}) do
            for k, v in pairs(tab) do
                -- printToAll("Copying over: "..k)
                o[k] = v
            end
        end
    end
    setmetatable(o, Card)
    Card.__index = Card
    Cache(CARDS,o)
    return o
end
SHIPS = {}
CARDS = {}
function onObjectSpawn(object)
    --Create a Button on the card for leaving a container
    if object.tag ~= "Figurine" and object.getName()~=nil and (SHIPS[string.lower(object.getName())] != nil or string.starts(object.getDescription(),"Custom")) then
        createSpawnButtons(object)
    end
end
-- function onObjectLeaveContainer(Container, object)
--     --Create a Button on the card for leaving a container
--     if SHIPS[object.getName()] != nil or string.starts(object.getDescription(),"Custom") then
--         createSpawnButtons(object)
--     end
-- end
function createSpawnButtons(object)
    object.clearButtons()
    object.createButton({label = "Spawn: "..object.getName(), click_function = 'Action_Spawn', rotation = {0, 0, 0},
    position = {0, 0.3, -2}, width = (40 * string.len("Spawn: "..object.getName())), height = 100, font_size = 75, function_owner = self, color={0,1,0}, font_color={0,0,0}})
    object.createButton({label = "Done", click_function = 'Action_DoneSpawn', rotation = {0, 0, 0},
    position = {0, 0.3, -2.8}, width = 320, height = 100, font_size = 75, function_owner = self, color={1,0,0}, font_color={1,1,1}})
    -- local data = SHIPS[object.getName()]
    -- data[12] = object.getGUID()
    -- data[13] = {}
    -- object.setTable('Details', data)
    if string.starts(object.getDescription(),"Custom") then
        printToAll("Loading definition for: "..(object.getName()) , {0,1,1})
        object.createButton({label = "Reload Custom Definition", click_function = 'createSpawnButtons', rotation = {0, 0, 0},
        position = {0, 0.3, -2.4}, width = 900, height = 100, font_size = 75, function_owner = self, color={0,1,1}, font_color={0,0,0}})
        -- printToAll("/begin desc",{1,1,1})
        -- printToAll(object.getDescription(),{1,1,1})
        -- printToAll("/end desc",{1,1,1})
        -- Custom|Ship|Large|mesh|diffuse|ruler|II|I,II|-,I,II
        local model_data = string:split(object.getDescription(),'\n',nil,false)
        local ship_data = {}
        -- printToAll(model_data[2],{1,1,1})
        -- printToAll(string.starts(model_data[2],"Ship"),{1,1,1})
        -- printToAll(model_data[3],{1,1,1})
        -- printToAll(string.starts(model_data[3],"Small"),{1,1,1})
        if string.strip(model_data[2])=="Ship" then
            -- 7 will be shields (F,L,R,B)
            -- local shields = list(map(int,string:split(model_data[7],",",nil,false)))
            -- local defense_tokens = string:split(model_data[8],",",nil,false)
            -- 8 will be defense
            local maneuver = {}
            -- lolnope loadstring("maneuver = "..model_data[7])
            table.insert(maneuver,string:split(string.strip(model_data[7]),",",nil,false))
            if #model_data>7 then
                table.insert(maneuver,string:split(string.strip(model_data[8]),",",nil,false))
            end
            if #model_data>8 then
                table.insert(maneuver,string:split(string.strip(model_data[9]),",",nil,false))
            end
            if #model_data>9 then
                table.insert(maneuver,string:split(string.strip(model_data[10]),",",nil,false))
            end
            ship_data = {
                mesh = string.strip(model_data[4]),
                diffuse = string.strip(model_data[5]),
                ruler = string.strip(model_data[6]),
                maneuver = maneuver,
                --defense_tokens = defense_tokens,
                --shields = shields,
                convex = true,
                type = 1,
                material = 3,
            }
            if string.strip(model_data[3])=="Small" then
                ship_data.collider = SmallShip.collider
            elseif string.strip(model_data[3])=="Medium" then
                ship_data.collider = MediumShip.collider
            elseif string.strip(model_data[3])=="Large" then
                ship_data.collider = LargeShip.collider
            end
        elseif string.strip(model_data[2])=="Squadron" then
            -- Custom|Squadron|mesh|diffuse|health|move
            ship_data = {
                mesh = string.strip(model_data[3]),
                diffuse = string.strip(model_data[4]),
                health =  string.strip(model_data[5]),
                move = string.strip(model_data[6]),
                collider = "http://paste.ee/r/nAMCQ",
                convex = false,
                type = 1,
                material = 1 }
        end
        object.setTable('Custom',ship_data)
    end
end
function Action_Spawn(card)
    if card.getTable('Custom') != nil then
        printToAll("Spawning Custom Ship",{0,1,1})
        spawnDefinition(card.getTable('Custom'),card.getName(),card.getPosition(),1,card.getRotation()[2])
    else
        spawnShip(card.getName(),card.getPosition(),1,card.getRotation()[2])
    end
end
function Action_DoneSpawn(card)
    card.clearButtons()
end
function onload()
#include defs/rebel/ships
#include defs/empire/ships
    local ship = nil

#include defs/rebel/squadrons
#include defs/empire/squadrons
    local ship = nil

#include defs/republic/ships
#include defs/separatist/ships
    local ship = nil

#include defs/republic/squadrons
#include defs/separatist/squadrons

#include defs/cards/commanders
#include defs/cards/defensive_retrofit
#include defs/cards/experimental_retrofit
#include defs/cards/fleet_command
#include defs/cards/fleet_support
#include defs/cards/ion_cannons
#include defs/cards/offensive_retrofit
#include defs/cards/officer
#include defs/cards/ordnance
#include defs/cards/superweapon
#include defs/cards/support_team
#include defs/cards/title
#include defs/cards/turbolaser
#include defs/cards/weapons_team_and_offensive_retrofit
#include defs/cards/weapons_team

#include defs/cards/objectives
    setRulerMeshes()
    drawListSpawnerButtons()
end
function setRulerMeshes()
    for _,ship in ipairs(getAllObjects()) do
        if ship.tag == 'Figurine' then
            for key,ship_def in pairs(SHIPS) do
                --printToAll("Checking Ship Def: "..key,{0,1,1})
                if ship_def.mesh == ship.getCustomObject().mesh then
                    ship.setVar("rulerMesh",ship_def.ruler)
                    --printToAll("set ruler for: "..ship_def.ruler,{0,1,1})
                end
            end
        end
    end
end
function drawListSpawnerButtons()
    for _,listSpawner in ipairs(getAllObjects()) do
        if listSpawner.getName()=="List Spawner" then
            Action_CloseListSpawner(listSpawner)
        end
    end
end
function Action_CloseListSpawner(listSpawner)
    listSpawner.clearButtons()
    listSpawner.clearInputs()
    listSpawner.createButton({label = ">", click_function = 'Action_OpenListSpawner', rotation = {0, 0, 0},
        position = {0.4, 0.4, -5.9}, width = 400, height = 400, font_size = 300, function_owner = self, color={0,1,0}, font_color={0,0,0}})

end
function Action_OpenListSpawner(listSpawner)
    listSpawner.clearButtons()
    listSpawner.clearInputs()
    listSpawner.createButton({label = "<", click_function = 'Action_CloseListSpawner', rotation = {0, 0, 0},
        position = {-0.4, 0.2, -5.9}, width = 400, height = 400, font_size = 300, function_owner = self, color={1,0,0}, font_color={0,0,0}})
    listSpawner.createInput({label = "paste list here", input_function = 'Input_UpdateList', rotation = {0, 0, 0},
        position = {3.2, 0.2, 0}, width = 3000, height = 6000, font_size = 85, function_owner = self, font_color={0,0,0}})
    listSpawner.createButton({label = "V V V     Spawn!     V V V", click_function = 'Action_SpawnListSpawner', rotation = {0, -90, 0},
        position = {7, 0.2, 0}, width = 6000, height = 500, font_size = 400, function_owner = self, color={0,1,0}, font_color={0,0,0}})
    listSpawner.createButton()
end
function Input_UpdateList(obj, color, input, stillEditing)
    obj.setVar("list",input)
end
function replace(input, pattern, replace)
    local output = string.gsub(input, pattern, replace)
    -- if output~=input then
    --     printToAll("Applied: '"..pattern.."'. '"..input.."' -> '"..output.."'")
    -- end
    return output
end
A_COLORS = {{1,0,0},
            {1,0.65,0},
            {1,1,0},
            {0.78,0.08,0.52},
            {0.55,0,0},
            {0.94,0.9,0.55},
            {0.87,0.63,0.87},
            {1,0.63,0.87},
            {1,0,1},
            {0.5,0.5,0}}
B_COLORS = {{0.1,0.1,0.44},
            {0.5,1,0},
            {0,0.75,1},
            {0.86,0.86,0.86},
            {0.18,0.55,0.34},
            {0,0,1},
            {0,0.98,0.6},
            {0,1,1},
            {0.48,0.41,0.93},
            {0.18,0.31,0.31}}
function clearSpawnArea(listSpawner)
    pos = listSpawner.getPosition()
    rot = listSpawner.getRotation()
    min_pos = vector.add(pos, vector.rotate({7,0,-5},rot[2]-180))
    max_pos = vector.add(pos, vector.rotate({88,0,14},rot[2]-180))
    -- printToAll("Destroying between: ("..min_pos[1]..","..min_pos[3]..") and ("..max_pos[1]..","..max_pos[3]..")",{1,0,0})
    for _,item in ipairs(getAllObjects()) do
        item_pos = item.getPosition()
        if ((item_pos[1]>min_pos[1] and item_pos[1]<max_pos[1]) or (item_pos[1]<min_pos[1] and item_pos[1]>max_pos[1])) and
           ((item_pos[3]>min_pos[3] and item_pos[3]<max_pos[3]) or (item_pos[3]<min_pos[3] and item_pos[3]>max_pos[3])) then
            -- print("Destroying: "..item.getName())
            item.destruct()
        end
    end
end
function Action_SpawnListSpawner(listSpawner)
    clearSpawnArea(listSpawner)
    -- local count = 0
    -- for k,v in pairs(SHIPS) do
    --     count = count+1
    -- end
    local list = listSpawner.getVar("list")
    -- print(#list)
    if list==nil or #list==0 then
        printToAll("Paste in fleet to spawn",{1,1,0})
        return
    end
    lines = string:split(list, "\n")
    -- print(#lines)
    -- x = 6
    -- i_y = 0
    -- max_i_y = 3
    -- y_offset = 3.5
    -- x_offset = 2.5

    fleet = {
        objectives = {},
        ships = {},
        squads = {}
    }

    last_ship = nil
    first_line = true
    line_objs = {}
    for _,line in ipairs(lines) do
        if first_line then
            first_line = false
        elseif not line:starts "=" then
            -- print("Parsing line: '"..line.."'")
            orig = line
            line = string.strip(line)
            count = string.match(line, "^•%s+(%d+)%s+x%s+")
            if count==nil then
                count = string.match(line, "^(%d+)%s+")
            end
            -- if count~=nil then
            --     print("Found count: "..tostring(count))
            -- end
            line = replace(line, "^Author:.*","")
            line = replace(line, "^Faction:.*","")
            line = replace(line, "^Commander:.*","")
            line = replace(line, "^Points:.*","")
            line = replace(line, "^Squadrons:.*","")
            line = replace(line, " Objective:",":") -- Shorten "Assault Objective: " to "Assault:"
            line = replace(line, "Assault: ","") -- Remove objective types
            line = replace(line, "Defense: ","") -- Remove objective types
            line = replace(line, "Navigation: ","") -- Remove objective types
            line = replace(line, "%s%+%s%d+%:%s%d+","") -- handle Starhawk-class Mk.II (150 + 84: 234)
            line = replace(line, "[%s ]+%(com%)","") -- remove " (com)" indicator
            line = replace(line, "[%s ]+%(off%)","") -- remove " (off)" indicator
            line = replace(line, "•%s+%d+%s+x%s+","") -- remove "• 2 x " for squadrons
            line = replace(line,"^%d+[%s ]+","") -- remove "2 " for squadrons
            line = replace(line, "^[•%-·][%s ]+","") -- remove all bullets NOTE: THAT IS NOT A NORMAL SPACE!
            -- line = replace(line,"^%-%s+","") -- replace by above
            line = replace(line,"[%s ]+%([%s ]*(%d+)[%s ]+points%)$"," (%1)") -- Shorten " ( 5 points)" -> " (5)"
            line = replace(line,"%[[%s ]+flagship[%s ]+%][%s ]+","") -- remove "[ flagship ]" indicato"
            line = replace(line,"%(%s*(%d+)%s*%)$","(%1)") -- shorten "( 5 )" to "(5)"
            line = string.strip(line) -- remove leading/training spaces
            line = replace(line," +"," ") -- remove all multiple spaces
            line_nocost = string.gsub(line,"[%s ]+%([%s ]*%d+[%s ]*%)$","") -- create version without trailing cost" (5)"
            cost = string.match(line,"[%s ]+%([%s ]*(%d+)[%s ]*%)$")

            if line ~="" then
                def = CARDS[string.lower(line)] or SHIPS[string.lower(line)] or CARDS[string.lower(line_nocost)] or SHIPS[string.lower(line_nocost)]
                if def==nil then
                    def = findDefinitionByName(SHIPS, line, true)
                end
                if def~=nil then
                    if def.type == "Objective" then --IS OBJECTIVE
                        table.insert(fleet.objectives, def)
                    elseif def.maneuver~=nil then --IS SHIP
                        last_ship = {def=def, upgrades = {}}
                        table.insert(fleet.ships, last_ship)
                    elseif def.move~=nil then
                        table.insert(fleet.squads, {def=def, count=tonumber(count)})
                    else --MUST BE UPGRADE????
                        if last_ship==nil then
                            printToAll("Cannot spawn upgrade: "..def.name.." since no ship found?",{1,0,0})
                        else
                            table.insert(last_ship.upgrades, def)
                        end
                    end
                else
                    printToAll("No definition found for: '"..line.."'",{1,0,0})
                end
            end
        end
    end

    layout(nil, fleet, listSpawner.getPosition(), listSpawner.getRotation())
end

function createSpawningStructure(lineobjs)

    fleet = {
        objectives = {},
        ships = {},
        squads = {}
    }
    last_ship = nil
    for _,obj in ipairs(lineobjs) do
        -- if line ~="" then
            -- def = CARDS[string.lower(line)] or SHIPS[string.lower(line)] or CARDS[string.lower(line_nocost)] or SHIPS[string.lower(line_nocost)]
            -- if def==nil then
                -- def = findDefinitionByName(SHIPS, line, true)
            -- end
        if obj.def~=nil then
            if obj.def.type == "Objective" then --IS OBJECTIVE
                table.insert(fleet.objectives, obj.def)
            elseif obj.def.maneuver~=nil then --IS SHIP
                last_ship = {def=obj.def, upgrades = {}}
                table.insert(fleet.ships, last_ship)
            elseif obj.def.move~=nil then
                table.insert(fleet.squads, {def=obj.def, count=tonumber(obj.count)})
            else --MUST BE UPGRADE????
                if last_ship==nil then
                    printToAll("Cannot spawn upgrade: "..obj.def.name.." since no ship found?",{1,0,0})
                else
                    table.insert(last_ship.upgrades, obj.def)
                end
            end
        else
            printToAll("No definition found for: '"..obj.original.."'",{1,0,0})
        end
        -- end
    end
    return fleet
end
-- lines {original="",parse="",cost="", def="",count=nil}
function findDefinitionByName(DEFS, name, fuzzy)
    def = DEFS[string.lower(name)]
    if fuzzy == true then
        printToAll("I can't find: '"..name.."'. Performing deep search...",{1,0,0})
        bestKey = fuzzyStringSearch(name)
        printToAll("The best I can find is: '"..tostring(bestKey).."'")
        def = SHIPS[bestKey]
        if def == nil then
            def = CARDS[bestKey]
        end
    end
    return def
end
function tablelength(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end
function fuzzyStringSearch(s)
    s = string.lower(s)
    -- print("#NGRAMS"..tablelength(NGRAMS))
    matches = {}
    n = #s
    s = " "..s.." "
    -- print("Searching: '"..s.."'")
    for i = 1,n do
        sub = string.sub(s,i,i+2)
        -- print("Looking for: '"..sub.."'")
        if NGRAMS[sub]~=nil then
            -- print("Potential "..#(NGRAMS[sub]).." matches for: "..sub)
            for _,match in ipairs(NGRAMS[sub]) do
                if matches[match]==nil then
                    matches[match] = 1
                else
                    matches[match] = matches[match]+1
                end
            end
        end
    end
    bestCount = 0
    best = nil
    for k,v in pairs(matches) do
        if v>bestCount then
            bestCount=v
            best = k
        end
    end
    return best
end
--{
--    objectives={def,def,def}
--    ships={{def, upgrades:{def, def, def, def, def},{def, upgrades:{def, def, def, def, def}}
--    squads={{def:def, count:1}}
--}
function layout(player, fleet, pos, rot)
    local x = 2 --9
    local i_y = 0
    local MAX_I_Y = 3
    local Y_OFFSET = 3.5
    local X_OFFSET = 2.5
    local OBJ_X_GAP = 4
    local SHIP_PRE_X_GAP = 1
    local SHIP_POST_X_GAP = 4.5
    local SQUAD_X_GAP = 5.5
    if (#fleet.ships * 2 + #fleet.squads) >12 then
        local x = 0 --8
        OBJ_X_GAP = 1.5
        X_OFFSET = 2.1
        SHIP_PRE_X_GAP = 0.8
        SHIP_POST_X_GAP = 3.5
        SQUAD_X_GAP = 3.5
    end
    local MAX_X = 86
    for i,def in ipairs(fleet.objectives) do
        printToAll("Objective: "..def.name,{1,1,1})
        spawnCard(def, pos, {x,0,4-(i-1)*Y_OFFSET}, vector.add(rot,{0,0,180}))
    end
    x = x+OBJ_X_GAP
    for i,ship in ipairs(fleet.ships) do
        if #ship.def.shields==6 then -- SSD GAP
            x = math.min(x+2, MAX_X)
        end
        i_y = 0
        printToAll("Ship: "..ship.def.name,{0,1,1})
        spawnCard(ship.def, pos, {x,0,3.3}, rot, 1)
        x = math.min(x+SHIP_PRE_X_GAP, MAX_X)
        if #ship.def.shields==6 then -- SSD GAP
            x = math.min(x+2, MAX_X)
        end
        for _,def in ipairs(ship.upgrades) do
            if i_y==0 then x = math.min(x+X_OFFSET, MAX_X) end
            printToAll("Upgrade: "..def.name,{1,1,0})
            -- print("("..x..","..i_y..")")
            spawnCard(def, pos, {x,0,4-i_y*Y_OFFSET}, rot, nil)
            -- print("math.mod("..i_y.."+1, "..MAX_I_Y..") = "..math.mod(i_y+1,MAX_I_Y))
            i_y = math.mod(i_y+1,MAX_I_Y)
        end
        if #ship.upgrades==0 then
            x = math.min(x+2, MAX_X)
        end
        x = math.min(x+SHIP_POST_X_GAP, MAX_X)
    end
    for i,squad in ipairs(fleet.squads) do
        if squad.count!=nil and squad.count>1 then
            printToAll("Squadron: "..squad.count.."x "..squad.def.name,{0,1,0})
        else
            printToAll("Squadron: "..squad.def.name,{0,1,0})
        end
        spawnCard(squad.def, pos, {x,0,3.3}, rot, squad.count)
        x = math.min(x+SQUAD_X_GAP, MAX_X)
    end
end
function spawnCard(def, pos, offset, rot, count) --TODO: count
    pos =  vector.add(pos,vector.rotate(offset, rot[2]-180))
    -- scale = {1.37,1,1.37}
    scale = {1,1,1}
    if def.maneuver~=nil then
        scale = {1.88,1,1.88}
    end
    if def.move~=nil then
        scale = {1.37,1,1.37}
    end
    local jsonRepresentation = {
      Name = "CardCustom",
      Transform = {
        posX = pos[1],
        posY = pos[2],
        posZ = pos[3],
        rotX = rot[1],
        rotY = rot[2],
        rotZ = rot[3],
        scaleX = scale[1],
        scaleY = scale[2],
        scaleZ = scale[3]
      },
      Nickname = def.name.." ("..def.cost..")",
      Hands = false,
      CardID = 2111,
      CustomDeck = {
        ["21"] = {
          FaceURL = def.front,
          BackURL = def.back,
          NumWidth = 1,
          NumHeight = 1,
          BackIsHidden = true,
          UniqueBack = false,
          Type = 0
        }
      }
    }
    if count~=nil and count>1 then
        jsonRepresentation['Nickname'] = "["..count.."]"..jsonRepresentation['Nickname']
    end
    -- if count~=nil and count>1 then
    --     jsonRepresentation['Description'] = "spawn "..count
    -- elseif  count~=nil and count==1 then
    --     jsonRepresentation['Description'] = "spawn"
    -- end
    spawnObjectJSON({
        json = JSON.encode(jsonRepresentation),
        callback_function = setCardDescriptionToSpawn
    })
end
function setCardDescriptionToSpawn(card)
    count = string.match(card.getName(), "^%[(%d+)%]")
    if count~=nil then
        count = tonumber(count)
        name = string.gsub(card.getName(),"^%[%d+%]","")
        card.setName(name)
        -- card.clearButtons()
    else
        name = card.getName()
        count = 1
    end
    Wait.frames(function() card.clearButtons() end, 2)
    spawnShip(name,card.getPosition(),count,card.getRotation()[2])
end
function spawnShip(name,pos,count,rotation)
    -- printToAll("Spawning: "..name,{1,0,0})
    local ship_def = SHIPS[string.lower(name)]
    spawnDefinition(ship_def,name,pos,count,rotation)
end
-- token_offsets = {{-0.86,0,-3.64},{0.86,0,-3.64},{-0.86,0,-4.94},{0.86,0,-4.94},{-0.86,0,-6.24},{0.86,0,-6.24}}
token_offsets = {{-0.86,0,3.54},{0.86,0,3.54},{-0.86,0,4.84},{0.86,0,4.84},{0.86,0,6.14},{0.86,0,6.14}}
function spawnDefinition(ship_def, name, pos,count,y_rotation)
    --local ship_def = SHIPS[name]
    if ship_def~=nil then
    --for _,ship_def in ipairs(SHIPS) do
    --    if ship_def.name == name then
        rotation_offset = 180
        if ship_def.health~=nil and ship_def.move~=nil then
            name = "("..ship_def.health.."/"..ship_def.health..") ["..ship_def.move.."] "..name
            rotation_offset = 0
        end
        for i=1, count, 1 do
            local obj_parameters = {}
            obj_parameters.type = 'Custom_Model'
            obj_parameters.position = vector.add({pos[1],4+i,pos[3]},vector.rotate({0,0,8},y_rotation-180))
            obj_parameters.rotation = {0,y_rotation-rotation_offset,0 }
            local ship = spawnObject(obj_parameters)
            local custom = {}
            custom.mesh = ship_def.mesh
            custom.collider = ship_def.collider
            custom.diffuse = ship_def.diffuse
            custom.convex = ship_def.convex
            custom.type = ship_def.type
            custom.material = ship_def.material
            ship.setCustomObject(custom)

            ship.setName(name)
            ship.setVar("rulerMesh",ship_def.ruler)
            ship.setTable("maneuver",ship_def.maneuver)
            ship.setTable("shields",ship_def.shields)
        end
        if ship_def.defense_tokens~=nil then
            for i,source_guid in ipairs(ship_def.defense_tokens) do
                source = getObjectFromGUID(source_guid)
                offset = token_offsets[i]
                local obj_parameters = {}
                obj_parameters.position = vector.sub(pos,vector.rotate(offset,y_rotation))
                obj_parameters.rotation = {0,y_rotation+90,0}
                source.takeObject(obj_parameters)
            end
        end
        if ship_def.maneuver~=nil then
            source = getObjectFromGUID(SPEED_SOURCE)
            offset = {3.44,0,4.19}
            local obj_parameters = {}
            obj_parameters.position = vector.sub(pos,vector.rotate(offset,y_rotation))
            obj_parameters.rotation = {0,y_rotation,0}
            source.takeObject(obj_parameters)
        end
        if ship_def.command~=nil then
            for i=1,ship_def.command do
                source = getObjectFromGUID(COMMAND_SOURCE)
                offset = {3.44,-i*0.5,8}
                local obj_parameters = {}
                obj_parameters.position = vector.sub(pos,vector.rotate(offset,y_rotation))
                obj_parameters.rotation = {0,y_rotation,0}
                source.takeObject(obj_parameters)
            end
        end
    --    end
    --end
    end
end
function math.mod(a, b)
    return a-b*math.floor(a/b)
end
function math.round(x)
    return x>=0 and math.floor(x+0.5) or math.ceil(x-0.5)
end
vector={}
function vector.add(pos, offset)
    return {pos[1] + offset[1],pos[2] + offset[2],pos[3] + offset[3]}
end
function vector.sub(pos, offset)
    return {pos[1] - offset[1],pos[2] - offset[2],pos[3] - offset[3]}
end
function vector.rotate(direction, yRotation)

    local rotval = math.round(yRotation)
    local radrotval = math.rad(rotval)
    local xDistance = math.cos(radrotval) * direction[1] + math.sin(radrotval) * direction[3]
    local zDistance = math.sin(radrotval) * direction[1] * -1 + math.cos(radrotval) * direction[3]
    return {xDistance, direction[2], zDistance}
end
function string.strip(str)
    return  string.gsub(str, '^%s*(.-)%s*$', '%1')
end
function string.starts(String,Start)
    return string.sub(String,1,string.len(Start))==Start
end
function string:split(this,sSeparator, nMax, bRegexp)
    assert(sSeparator ~= '')
    assert(nMax == nil or nMax >= 1)

    local aRecord = {}

    if this:len() > 0 then
        local bPlain = not bRegexp
        nMax = nMax or -1

        local nField, nStart = 1, 1
        local nFirst,nLast = this:find(sSeparator, nStart, bPlain)
        while nFirst and nMax ~= 0 do
            aRecord[nField] = this:sub(nStart, nFirst-1)
            nField = nField+1
            nStart = nLast+1
            nFirst,nLast = this:find(sSeparator, nStart, bPlain)
            nMax = nMax-1
        end
        aRecord[nField] = this:sub(nStart)
    end

    return aRecord
end
function table.copy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
            copy[orig_key] = orig_value
        end
    else -- number, string, boolean, etc
    copy = orig
    end
    return copy
end

function table.contains(self, val)
    for index, value in ipairs (self) do
        if value == val then
            return true
        end
    end

    return false
end
